## 코드

```python
t=int(input())

for _ in range(t):
    n,m= map(int, input().split())
    queue=list(map(int, input().split()))
    
    cnt=0

    while (m!=-1):
        if queue[0]==max(queue):
            del queue[0]
            cnt+=1
            m-=1
        else:
            queue.append(queue[0])
            del queue[0]
            
            if (m==0):
                m=len(queue)-1
            else:
                m-=1

    print(cnt)
```

## 문제

### 문제

 여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.

1. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
2. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 **Queue의 가장 뒤에 재배치** 한다. 그렇지 않다면 바로 인쇄를 한다.

예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.

여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.

### 입력

 첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.

 테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

### 출력

 각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.

### 문제 분석

 입력과 출력에 집중하기 보다는 문제를 잘 읽어야 한다. 조건 2가지가 문제를 해결하는 알고리즘이다.  입력받은 m번째 인덱스에 해당하는 값이 언제 인쇄되는지를 요구한다. queue라는 리스트를 만들어 리스트에 문서 중요도를 입력 받고, queue의 첫번째 인덱스에 해당하는 값이 가장 크다면 인쇄, 아니면 큐의 가장 뒤에 붙인다. 따라서 정리한 문제 해결 방법은 다음과 같다.

1. queue에 문서 중요도 입력 받는다.
2. queue[0]에 해당하는 값이 가장 크다면 인쇄(삭제)
    1. m이 몇번째로 인쇄되는지 확인하기 위한 cnt 값에 +1
    2. 하나가 인쇄되어 나갔으므로 m에 -1
3. 가장 크지 않다면 queue의 뒤에 붙인(append) 후, 삭제
    1. 이때 m이 0번째 인덱스였다면 맨 뒤에 가야하므로 m=len(queue)-1
    2. m이 0번째 인덱스가 아니라면(0보다 크다면) m에 -1
4. 계속 반복하다가 m이 인쇄될 때, 즉 m이 -1일 때(2번에 해당한다. 이때 m의 값은 0이므로 2를 수행하며 m은 -1이 된다.) 반복을 종료한다.

## 큐(queue)

**큐의 이해**

- 큐는 FIFO(First-in, Firstst-out) 구조의 자료구조이다.
- 먼저 들어간 것이 먼저 나오는, 일종의 줄서기에 비유할 수 있는 자료구조이다.
- 큐의 기본연산
    - enqueue : 큐에 데이터를 넣는 연산
    - dequeue : 큐에서 데이터를 꺼내는 연산
- 큐는 운영체제 관점에서 보면 프로세스나 쓰레드의 관리에 활용이 되는 자료구조이다.
- 이렇듯 운영체제의 구현에도 자료구조가 사용이 된다. 따라서 운영체제의 이해를 위해서는 자료구조에 대한 이해가 선행되어야 한다.

## 코드 리뷰

 위의 문제 분석을 그대로 코드로 작성한다.

1. testcase동안 반복한다.
2. queue라는 리스트를 생성하여 문서 중요도를 입력받음. & 답을 저장할 cnt 선언
3. m이 -1이 될 때까지
    1. queue[0]에 해당하는 값이 가장 크다면
        1. queue[0]삭제 → 인쇄
        2. 인쇄 되었으므로 cnt 하나 증가
        3. m은 앞으로 당겨졌으므로 -1을 더해줌
    2. 크지 않다면
        1. queue에 맨 앞에 있는 값을 맨 뒤로 보냄(append)
        2. 맨 앞에 있는 값 삭제
        3. 만약 m이 0번째라면
            1. m은 가장 뒤로 가야하므로 len(queue)-1
            2. 아니라면(m>0) m에 -1 더해줌

**사용 문법**

- 입력 값을 변수 두 개에 저장하기
    
    n,m= map(int, input().split())