## 코드

```python
import sys
import heapq

N=int(input())
heap=[]

for _ in range(N):
    x=int(sys.stdin.readline())
    if x!=0:
        if x>0:
            heapq.heappush(heap,(x,x))
        else:
            heapq.heappush(heap,(-x,x))
    else:
        if len(heap)==0:
            print(0)
        else:
            print(heapq.heappop(heap)[1])
```

## 문제

### 입력

 첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.

### 출력

 입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.

### 문제 분석

## 코드 리뷰

1. 리스트 heap을 정의한 후, N번 동안 x의 정수를 입력받는다. 시간을 빠르게 하기 위해 sys함수를 사용한다.
2. x가 0이 아니라면 다음을 수행한다.
    1. x가 0보다 크다면 그대로 heap에 x값을 넣는다.
    2. x가 0보다 작다면 heap에 -x값을 넣는다.
3. 0이라면, 다음을 수행한다. 
    1. heap에 비어있는 경우는 heap의 길이가 0인 경우이다. len(heap)이 0이라면 0을 출력한다.
    2. 0이 아니라면 비어있는 경우가 아니므로, heap에서 그 값을 제거하면서 print한다.
    

**사용 문법**

- **heapq.heappush(heap,(x,x)) 와heapq.heappush(heap,(-x,x))**
    
     힙에 튜플(tuple)을 원소로 추가하거나 삭제하면, 튜플 내에서 맨 앞에 있는 값을 기준으로 최소 힙이 구성된다. 따라서 (우선 순위, 값) 구조의 튜플을 힙에 추가하거나 삭제한다.
    
    - x가 0보다 작을 경우:
        
        우선순위는 x의 양수 형태를 가지고 우선순위를 결정하므로 -x형태로 전달해야 하며, 값은 x값 그대로 저장한다.
        
    - 읽어올 때:
        
        힙에서 값을 읽어올 때는 우선 순위는 상관없고, 값만을 요구하므로 각 튜플에서 인덱스 1에 있는 값을 취하면 된다.
        
        → **heapq.heappop(heap)[1]**
        
        - abs : 절댓값 함수