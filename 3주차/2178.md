# 2178 미로탐색

[2178번: 미로 탐색](https://www.acmicpc.net/problem/2178)

# 문제

## 문제

N×M크기의 배열로 표현되는 미로가 있다.

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

## 입력

첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 **붙어서** 입력으로 주어진다.

## 출력

첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

## 알고리즘 분류

- [그래프 이론](https://www.acmicpc.net/problem/tag/7)
- [그래프 탐색](https://www.acmicpc.net/problem/tag/11)
- [너비 우선 탐색](https://www.acmicpc.net/problem/tag/126)

## 문제분석

큐, bfs

# 코드

```python
import sys
from collections import deque

#N.M을 공백을 기준으로 구분하여 입력 받기
n,m = map(int, sys.stdin.readline().rstrip().split())
#2차원 리스트에 맵 정보 입력 받기
graph=[]
for i in range(n):
    graph.append(list(map(int,input())))

#이동할 네 가지 방향 정의(상,하,좌,우)
dx=[-1,1,0,0]
dy=[0,0,-1,1]

#bfs 소스코드 구현

def bfs(x,y):
    #큐 구현을 위해 deque 라이브러리 사용
    queue = deque()
    queue.append((x,y))
    #큐가 빌 때까지 반복하기
    while queue:
        x,y=queue.popleft()
        #현재 위치에서 4가지 방향으로의 위치 확인
        for i in range(4):
            nx=x+dx[i]
            ny=y+dy[i]
            #미로 찾기 공간을 벗어난 경우 무시
            if nx<0 or nx>=n or ny<0 or ny>=m:
                continue
            #벽인 경우 무시
            if graph[nx][ny]==0:
                continue
            #해당 노드를 처음 방문하는 경우에만 최단 거리 기록
            if graph[nx][ny]==1:
                graph[nx][ny]=graph[x][y]+1
                queue.append((nx,ny))
    #가장 오른쪽 아래까지의 최단 거리 반환
    return graph[n-1][m-1]

print(bfs(0,0))
```

3주차 강의의 미로찾기 문제 코드와 같다.

1. BFS는 시작 지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색한다.
2. 상, 하, 좌, 우로 연결된 모든 노드로의 거리가 1로 동일하다.
    1. 따라서 (1,1) 지점부터 BFS를 수행하여 모든 노드의 최단 거리 값을 기록한다.
3. 처음에 (1,1)의 위치에서 시작한다.
4. (1,1) 좌표에서 상,하,좌,우로 탐색을 진행하면 바로 옆 노드인 (1,2) 위치의 노드를 방문하게 되고 새롭게 방문하는 (1,2)노드의 값을 2로 바꾼다.
5. 마찬가지로 bfs를 계속 수행하면 결과적으로 최단 경로의 값들이 1씩 증가하는 형태로 변경된다.

1. n과 m의 값을 입력받고, 2차원 데이터가 담길 수 있는 맵 정보를 입력 받는다.
2. 방향 벡터를 정의해 준 후, bfs를 실행한다.
3. 큐를 구현하기 위해 deque를 사용한다. 
4. 초기에 큐에 x,y로 이루어진 튜플 데이터를 담고, 큐가 빌 때까지 bfs를 반복한다.
    1.  반복할 때마다 큐에서 하나의 원소를 꺼내어 현재 위치에서 네 가지 방향으로의 위치를 확인한다. 
    2. 그 다음으로 연결된 위치가 공간을 벗어나거나 벽인 경우 무시한다.
    3. 결과적으로, 해당 노드를 처음 방문하는 경우에만 최단 거리를 기록하도록 한다.
    4. 바로 직전 노드 위치에서의 최단 거리 값에 1을 더한 값을 넣어준다. 다음으로 이동할 위치 값은 1만큼 거리가 먼 곳이기 때문에 큐에 데이터를 넣으면서 거리 값을 1 증가시킬 수 있다.
5. 마지막으로 가장 오른쪽까지의 최단 거리를 반환하면 된다.